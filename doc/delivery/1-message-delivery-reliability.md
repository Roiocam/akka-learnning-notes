# 通用原则

在 Akka 中消息投递的遵循以下原则：

- **最多一次交付 At Most Once**，不保证交付。
- **保证每个发送者-接收者之间消息有序**，不保证多个发送者-接收者有序


    投递 = 交付 = Deliver(v.)

## 1. 交付语义

| 语义 | 含义(发送给交付机制的消息) | 性能 | 原理 |
| ------ | ------ |------ |------ |
| **最多一次** | 只会投递一次或者不投递。`消息可能丢失` | 性能高,开销低 | 即发即忘 <br>  发送端：不维护状态 <br> 接收端：不维护状状态|
| **最少一次** | 可能会被多次投递，这样至少又一个是成功交付的。`消息可能重复但不会丢失` | 中等 | <br>  发送端：维护状态，实现重试机制 <br> 接收端：实现确认机制 |
| **精确一次** | 对于接收者只会投递一次。`消息不会丢失不会重复` | 低性能,高开销 |  发送端：维护状态，实现重试机制 <br> 接收端：维护状态过滤重复交付，实现确认机制|

## 2. 消息排序

围绕三个点，
1是点对点之间的消息，Akka保证有序 
2是多个发送者到一个接受者之间的消息，不保证全部有序
3是普通消息和系统级别的消息之间不保证有序

## 3. Akka 为什么不对消息的投递做保证

这个问题的核心在于投递保证意味着什么？

1. 消息是否在网络中传输
2. 消息是否被其他主机接收
3. 消息是否被放入了目标 Actor 的消息邮箱
4. 消息是否被目标 Actor 开始处理
5. 消息是否被目标 Actor 成功处理

上述每一个都有着不同的挑战。Akka 框架从两个角度说明为什么不将投递保证作为基本原则。

- 对于发送方来说，交互是否成功的唯一有意义的方式就是接收来自业务级别的确认消息。而 Akka 框架的设计理念不是"按我的意思做"，也就是 Akka 不负责如何实现业务层面的确认
- 另一个角度是，在基本保证之上实现可靠交付容易，而为了追求性能追溯性地(`retro-actively `)移除可靠交付的实现困难。


# 本地消息发送原则（In-JVM）

